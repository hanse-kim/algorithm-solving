## 2019 ì¹´ì¹´ì˜¤ ë¸”ë¼ì¸ë“œ ì±„ìš© - í›„ë³´í‚¤ [ğŸ”—](https://programmers.co.kr/learn/courses/30/lessons/42890)

 ### í’€ì´

ê°€ëŠ¥í•œ í›„ë³´í‚¤ ì¡°í•©ì„ ëª¨ë‘ ë§Œë“¤ì–´ í™•ì¸í•œë‹¤. í•´ë‹¹ ì¡°í•©ì´ í›„ë³´í‚¤ì¼ ê²½ìš°(ì¦‰ í•´ë‹¹ ì—´ë§Œ ì¶”ì¶œí•´ë„ ì¤‘ë³µí–‰ì´ ì—†ì„ ê²½ìš°) í•´ë‹¹ ì¡°í•©ì´ í¬í•¨ëœ ë” í° ì¡°í•©ì€ ëª¨ë‘ ë¬´ì‹œí•œë‹¤.

```python
import itertools

def solution(relation):
    relation_size = len(relation)
    column_size = len(relation[0])
    column_index_range = range(column_size)
    key_combinations = list(itertools.chain.from_iterable( 
        itertools.combinations(column_index_range, r) for r in range(1, column_size + 1) ))

    candidate_keys = []
    result = 0
    while key_combinations:
        key = set(key_combinations.pop(0))
        subset_is_candidate_key = [ 0 for ckey in candidate_keys if ckey.issubset(key) ]
        if subset_is_candidate_key:
            continue

        sub_relation = { tuple([ row[i] for i in key ]) for row in relation }
        if len(sub_relation) == relation_size:
            result += 1
            candidate_keys.append(key)

    return result
```

