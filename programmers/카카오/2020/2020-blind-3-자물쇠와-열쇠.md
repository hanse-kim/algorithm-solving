## 2020 ì¹´ì¹´ì˜¤ ë¸”ë¼ì¸ë“œ ì±„ìš© - ìë¬¼ì‡ ì™€ ì—´ì‡  [ğŸ”—](https://programmers.co.kr/learn/courses/30/lessons/60058)

í¬ê¸° `M*M`ì¸ ì—´ì‡ ì™€ `N*N`ì¸ ìë¬¼ì‡ ê°€ ìˆë‹¤. ì—´ì‡ ì™€ ìë¬¼ì‡ ëŠ” ê° ê²©ìì— í™ˆ(0)ê³¼ ëŒê¸°(1)ê°€ ìˆê³ , ì—´ì‡ ì˜ ëŒê¸°ê°€ ìë¬¼ì‡ ì˜ í™ˆì— ë§ë¬¼ë ¤ì•¼ ì—´ë¦°ë‹¤. ëŒê¸°ë¼ë¦¬ ë§Œë‚˜ê±°ë‚˜, ìë¬¼ì‡ ì˜ í™ˆì´ ë‚¨ì•„ìˆìœ¼ë©´ ì—´ë¦¬ì§€ ì•ŠëŠ”ë‹¤. ì—´ì‡ ëŠ” 90ë„ íšŒì „ ë° ì´ë™ì´ ê°€ëŠ¥í•˜ê³ , ì´ë•Œ ìë¬¼ì‡  ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ëŠ” ì—´ì‡  ë¶€ë¶„ì€ ë¬´ì‹œí•œë‹¤.

ì—´ì‡ ì™€ ìë¬¼ì‡ ê°€ 2ì°¨ì› ë°°ì—´ë¡œ ì£¼ì–´ì§ˆ ë•Œ, ì´ ì—´ì‡ ë¡œ ìë¬¼ì‡ ë¥¼ ì—´ ìˆ˜ ìˆëŠ”ì§€ íŒë³„í•˜ë¼.

- keyëŠ” M x M(3 â‰¤ M â‰¤ 20, Mì€ ìì—°ìˆ˜)í¬ê¸° 2ì°¨ì› ë°°ì—´ì…ë‹ˆë‹¤.
- lockì€ N x N(3 â‰¤ N â‰¤ 20, Nì€ ìì—°ìˆ˜)í¬ê¸° 2ì°¨ì› ë°°ì—´ì…ë‹ˆë‹¤.
- Mì€ í•­ìƒ N ì´í•˜ì…ë‹ˆë‹¤.
- keyì™€ lockì˜ ì›ì†ŒëŠ” 0 ë˜ëŠ” 1ë¡œ ì´ë£¨ì–´ì ¸ ìˆìŠµë‹ˆë‹¤.
  - 0ì€ í™ˆ ë¶€ë¶„, 1ì€ ëŒê¸° ë¶€ë¶„ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤

 ### í’€ì´

ëª¨ë“  íšŒì „ ë° ì´ë™í•˜ëŠ” ê²½ìš°ì˜ ìˆ˜ë¥¼ ì „ë¶€ í™•ì¸í•œë‹¤. 

* ë¡œì§
  * ì—´ì‡  ë¦¬ìŠ¤íŠ¸ë¥¼ ë§Œë“¤ê³  ì£¼ì–´ì§„ ì—´ì‡ ì™€ 90ë„, 180ë„, 270ë„ íšŒì „ì‹œí‚¨ ì—´ì‡ ë¥¼ ì¶”ê°€í•œë‹¤.
  * ê° ì—´ì‡ ê°€ ìë¬¼ì‡ ë³´ë‹¤ ì‘ë‹¤ë©´ ë¶€ì¡±í•œ í¬ê¸°ë§Œí¼ 0ìœ¼ë¡œ ì´ë£¨ì–´ì§„ ê³µë°±ì„ ì¶”ê°€í•œë‹¤.
  * ê° ì—´ì‡ ë³„ë¡œ ë‹¤ìŒì„ ìˆ˜í–‰í•œë‹¤.
    * ì´ë™ ë²”ìœ„(ì›ë˜ ì—´ì‡  í¬ê¸°ì™€ ìë¬¼ì‡  í¬ê¸°ë¡œ êµ¬í•œë‹¤) ë‚´ì—ì„œ ê°€ë¡œ ì´ë™ëŸ‰ê³¼ ì„¸ë¡œ ì´ë™ëŸ‰ì„ ì •í•˜ê³  ê° ì´ë™ëŸ‰ë§Œí¼ ì´ë™ì‹œí‚¨ ì—´ì‡ ë¥¼ ìë¬¼ì‡ ì™€ ë¹„êµí•˜ì—¬ ë§ëŠ”ì§€ ì•ˆ ë§ëŠ”ì§€ íŒë‹¨í•œë‹¤.
  * ë§ëŠ” ì—´ì‡ ê°€ ì—†ìœ¼ë©´ Falseë¥¼ ë°˜í™˜í•œë‹¤.

* í—¤ë©˜ ë¶€ë¶„
  * get_empty_key()
    * ì²˜ìŒì—ëŠ” `[[ 0 for _ in range(size) ]] * size `ë¡œ êµ¬í–ˆëŠ”ë°, ì´ëŸ¬ë©´ ê° rowê°€ ëª¨ë‘ ë™ì¼í•œ ì£¼ì†Œë¥¼ ê°€ë¦¬ì¼œì„œ ê°’ í•˜ë‚˜ë§Œ ë°”ê¾¸ì–´ë„ í•´ë‹¹ columnì˜ ê°’ì´ ëª¨ë‘ ë°”ë€Œì–´ë²„ë¦°ë‹¤.
      ë¦¬ìŠ¤íŠ¸ ì»´í”„ë¦¬í—¨ì…˜ì„ ë‘ ë²ˆ ì‚¬ìš©í•˜ëŠ” ê±¸ë¡œ ìˆ˜ì •í–ˆë‹¤.
  * check()
    * keyì™€ lockì˜ ê°™ì€ ìœ„ì¹˜ì— ìˆëŠ” ê°’ì„ ë”í•˜ì—¬ (í™ˆê³¼ ëŒê¸°ê°€ ë§Œë‚˜ë©´ 1 + 0 = 1ì´ë¯€ë¡œ) 1ì´ ì•„ë‹ˆë¼ë©´ Falseë¥¼ ë°˜í™˜í•œë‹¤. ì²˜ìŒì—ëŠ” `lock[i][j] += key[i][j]`ë¥¼ í•œ ë’¤ `lock[i][j]`ê°€ 1ì´ ì•„ë‹Œì§€ í™•ì¸í–ˆëŠ”ë°, ì´ëŸ¬ë©´ ì°¸ì¡°í•œ `lock`ì˜ ê°’ì´ ë°”ë€Œì–´ì„œ ë‹¤ìŒ ë£¨í”„ë¶€í„° ê¼¬ì—¬ë²„ë¦°ë‹¤.
      `lock[i][j] + key[i][j]` ê°’ì„ ë°”ë¡œ í™•ì¸í•˜ëŠ” ê²ƒìœ¼ë¡œ ìˆ˜ì •í–ˆë‹¤.

```python
def solution(key, lock):
    if sum(map(sum, key)) == 0:
        return False
    
    def get_empty_key(size: int):
        return [ [ 0 for _ in range(size) ] for _ in range(size)]
    
    def rotate(key):
        key_size = len(key)
        rotated_key = get_empty_key(key_size)
        for i in range(key_size):
            for j in range(key_size):
                rotated_key[i][j] = key[j][(key_size - 1) - i]
        return rotated_key
    
    def zero_padding(key, lock_size):
        key_size = len(key)
        if key_size == lock_size:
            return key
        padding_key = get_empty_key(lock_size)
        for i in range(key_size):
            for j in range(key_size):
                padding_key[i][j] = key[i][j]
        return padding_key
    
    def shift(key, i_shift, j_shift):
        key_size = len(key)
        shifted_key = get_empty_key(key_size)
        for i in range(key_size):
            shifted_i = i + i_shift
            if is_out_of_range(shifted_i, key_size):
                continue
            for j in range(key_size):
                shifted_j = j + j_shift
                if is_out_of_range(shifted_j, key_size):
                    continue
                shifted_key[i][j] = key[shifted_i][shifted_j]
        return shifted_key
    
    def is_out_of_range(value, value_range) -> bool:
        if value < 0 or value >= value_range:
            return True
        return False
    
    def check(key, lock) -> bool:
        lock_size = len(lock)
        for i in range(lock_size):
            for j in range(lock_size):
                # ì²˜ìŒì—ëŠ” lock[i][j] += key[i][j]ë¥¼ í•˜ê³ 
                # lock[i][j]ì˜ ê°’ì´ 1ì¸ì§€ íŒë³„í–ˆëŠ”ë°,
                # ì´ëŸ¬ë©´ ì°¸ì¡°í•œ lockì˜ ê°’ì´ ë°”ë€Œë©´ì„œ ë‹¤ìŒ ë£¨í”„ë¶€í„° ê¼¬ì´ê²Œ ëœë‹¤..
                if lock[i][j] + key[i][j] != 1:
                    return False
        return True
    
    keys = [key]
    while len(keys) < 4:
        keys.append(rotate(keys[-1]))
    
    keys = [ zero_padding(k, len(lock)) for k in keys ]
    
    shift_range = range(-(len(lock) - 1), len(key))
    for k in keys:
        for i_shift in shift_range:
            for j_shift in shift_range:
                k_tmp = k
                if not (i_shift == 0 and j_shift == 0):
                    k_tmp = shift(k, i_shift, j_shift)
                if check(k_tmp, lock):
                    return True
    
    return False
```
