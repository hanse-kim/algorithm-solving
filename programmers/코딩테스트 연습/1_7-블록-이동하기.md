## 2020 ì¹´ì¹´ì˜¤ ë¸”ë¼ì¸ë“œ ì±„ìš© - ë¸”ë¡ ì´ë™í•˜ê¸° [ğŸ”—](https://programmers.co.kr/learn/courses/30/lessons/60063)

 ### í’€ì´

ë¡œë´‡ì´ í•œ ìœ„ì¹˜ì—ì„œ í•  ìˆ˜ ìˆëŠ” í–‰ë™ì€ ì´ 8ê°€ì§€ì´ë‹¤.

- 4ê°€ì§€ ì´ë™ (ìƒ, í•˜, ì¢Œ, ìš°)
- 4ê°€ì§€ íšŒì „ (2ê°œì˜ ì¶•ê³¼ ì‹œê³„/ë°˜ì‹œê³„ ë°©í–¥)

ì´ë™ê³¼ íšŒì „ ëª¨ë‘ ì‹œê°„ì´ 1ì´ë¯€ë¡œ, ë¡œë´‡ì´ ìˆì„ ìˆ˜ ìˆëŠ” ê° ìœ„ì¹˜ë¥¼ ë…¸ë“œë¡œ ì‚¼ê³ , í•´ë‹¹ ìœ„ì¹˜ì—ì„œ ì´ë™ ë° íšŒì „ìœ¼ë¡œ ì›€ì§ì¼ ìˆ˜ ìˆëŠ” ìœ„ì¹˜ë¥¼ ë‹¤ìŒ ë…¸ë“œë¡œ ì‚¼ëŠ” ê·¸ë˜í”„ë¥¼ ìƒì„±í•œ í›„ BFSë¡œ ìµœë‹¨ê±°ë¦¬ë¥¼ êµ¬í•œë‹¤.

```python
import collections

# ë…¸ë“œëŠ” x(int), y(int), is_horizontal(bool) 3ê°œì˜ ìš”ì†Œë¥¼ ê°–ëŠ” íŠœí”Œì´ë‹¤.

# ê·¸ë˜í”„ë¥¼ ìƒì„±í•œë‹¤.
def get_graph(board):
    graph = {}
    N = len(board)
    for y in range(1, N + 1):
        for x in range(1, N + 1):
            # ê° ì¢Œí‘œì—ì„œ ë¡œë´‡ ë°©í–¥ì´ ìˆ˜í‰/ìˆ˜ì§ì¼ ê²½ìš°ë¥¼ ê°ê° ê·¸ë˜í”„ì— ì¶”ê°€í•œë‹¤.
            graph[(x, y, True)] = get_next_node((x, y, True), board)
            graph[(x, y, False)] = get_next_node((x, y, False), board)
    return graph

# í˜„ì¬ ë…¸ë“œì—ì„œ ë‹¤ìŒ ë…¸ë“œë“¤ì„ êµ¬í•œë‹¤.
def get_next_node(node, board):
    x, y, is_horizontal = node
    next_node_candidates = [
        # ì´ë™í•˜ëŠ” ê²½ìš°
        (x + 1, y, is_horizontal),
        (x - 1, y, is_horizontal),
        (x, y + 1, is_horizontal),
        (x, y - 1, is_horizontal),
        # íšŒì „í•˜ëŠ” ê²½ìš°
        (x, y, not is_horizontal),
        (x + 1, y, not is_horizontal) if is_horizontal else (x, y + 1, not is_horizontal),
        (x, y - 1, not is_horizontal) if is_horizontal else (x - 1, y, not is_horizontal),
        (x + 1, y - 1, not is_horizontal) if is_horizontal else (x - 1, y + 1, not is_horizontal)
    ]
    # ë‹¤ìŒ ë…¸ë“œ í›„ë³´ ì¤‘ validí•œ ë…¸ë“œë§Œ ë½‘ì•„ì„œ returní•œë‹¤.
    return [ next_node for next_node in next_node_candidates if is_valid_next_node(node, next_node, board) ]

# ì´ë™í•œ ë…¸ë“œê°€ ì ì ˆí•œì§€ í™•ì¸í•œë‹¤.
# ì´ë™ ì „, í›„ì— ë¡œë´‡ì´ ìœ„ì¹˜í•˜ëŠ” ê° ì¢Œí‘œë¥¼ ëª¨ë‘ êµ¬í•´ì„œ,
# ê° ì¢Œí‘œê°€ board ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ê±°ë‚˜ ë²½ì´ ìˆëŠ”ì§€ ì²´í¬í•œë‹¤.
# íšŒì „ì¼ ê²½ìš°, íšŒì „í•˜ëŠ” ë° í•„ìš”í•œ ê³µê°„ì˜ ì¢Œí‘œë¥¼ ì¶”ê°€ë¡œ ì²´í¬í•œë‹¤.
def is_valid_next_node(origin_node, next_node, board):
    coord_for_check = set()
    for node in (origin_node, next_node):
        x, y, is_horizontal = node
        coord_for_check = coord_for_check | {(x, y), (x + 1, y) if is_horizontal else (x, y + 1)}
    # íšŒì „ì¼ ê²½ìš°, 'ì§ì‚¬ê°í˜•ì„ ì™„ì„±í•˜ê¸°' ë¬¸ì œì™€ ê°™ì€ ë°©ì‹ìœ¼ë¡œ
    # íšŒì „ì— í•„ìš”í•œ ê³µê°„ì˜ ì¢Œí‘œë¥¼ êµ¬í•œë‹¤.
    if origin_node[2] != next_node[2]:
        extra_coord = []
        for v in zip(*list(coord_for_check)):
            extra_coord.append(collections.Counter(v).most_common()[1][0])
        coord_for_check.add(tuple(extra_coord))
    
    N = len(board)
    for coord in list(coord_for_check):
        x, y = coord
        # ë²”ìœ„ë¥¼ ë²—ì–´ë‚œ ê²½ìš°
        if x < 1 or y < 1 or x > N or y > N:
            return False
        # ë²½ì¸ ê²½ìš°
        if board[y - 1][x - 1] == 1:
            return False
    return True

# í•´ë‹¹ ë…¸ë“œê°€ ëª©ì ì§€ì— ë„ì°©í–ˆëŠ”ì§€ í™•ì•ˆí•œë‹¤.
def is_goal(node, destination):
    x, y, is_horizontal = node
    if is_horizontal and (x + 1, y) == destination:
        return True
    if not is_horizontal and (x, y + 1) == destination:
        return True
    return False

def solution(board):
    graph = get_graph(board)
    visited = {}
    start = (0, (1, 1, True)) # (ì‹œê°„, ë…¸ë“œ)
    queue = collections.deque([start])
    N = len(board)
    destination = (N, N)
    while queue:
        time, node = queue.popleft()
        if node in visited:
            continue
        
        if is_goal(node, destination):
            return time
        
        queue.extend([ (time + 1, next_node) for next_node in graph[node] ])
        visited[node] = time
```
